% chap1.tex - Week 1
\chapter{Semaine 1}
\section{Jour 1 - ``Les choses doivent changer''}
\subsection{Réunir l'équipe}
Si vous êtes déjà un utilisateur chevronné de contrôle de version, vous pourriez vouloir sauter ce chapitre.
C'est une sorte d'introduction à pourquoi nous avons même besoin de systèmes de contrôle de version en premier lieu.
Ce chapitre observe aux besoins de Tamagoyaki Inc. et pourquoi ils choisissent le VCS (NDT: Version Control System, ce terme standard ne sera pas traduit dans la suite du document) qui semblait leur convenir.
Tamagoyaki Inc. crée un logiciel qui transforme un PC standard en media center.
Leur produits est destiné à l'utilisateur final et ils sont fortement dépendants d'une bonne présence aux salons commerciaux, pour ramener des ventes.
La conversation suivante décrit les évènements qui ont conduit à l'établissement de la discussion "Nous avons besoin d'un VCS!".

\begin{trenches}
John s'assit à son bureau et regarda à travers la fenêtre.
La bruine tombait sur le volet, mais il s'en fichait.
C'était un lundi tranquille, la livraison s'était bien déroulée vendredi et John était juste en train de penser à l'implémentation the la nouvelle couche d'abstraction à la base de données qui lui avait été demandée.
``John,'' hurla son patron, Markus, ``amenez votre équipe dans la salle de présentation. Maintenant !''

Les choses ne se présentaient pas bien.

\thoughtbreak

``Alors, ce que nous aimerions savoir John, c'est juste comment un bug qui était supposé avoir été corrigé\ldots'' le PDG se reprit,

``qui avait été certifié comme étant fixé il y a 2 semaines, a pu se glisser dans la dernière version de notre logiciel ?''

``Je suis désolé,'' commença John, avant d'être interrompu.

``Être désolé ne suffit pas John,'' dit le PDG, Wayne Tobi,
``Ce fut presque une déconfiture majeure pour Tamgayoki Inc. et nous avons besoin de nous assurer que cela ne se reproduise pas à nouveau. Ladémonstration au salon était à 2 doigts de l'échec complet. Heureusement quelqu'un avait eu le bon sens d'amener une machine de sauvegarde.''

Il se tourna vers Markus.
``Je veux un rapport sur mon bureau d'ici la fin de la journée qui explique quel était le problème, comment il nous a glissé des mains et quelles mesures préventives nous allons mettre en oeuvre pour que des choses comme ça ne se reproduise plus jamais.''

``Bien sur monsieur,'' répondit Markus.
Il était rouge vif avec un embaras tout personnel.

La pièce devint silencieuse et quelques minutes de silence s'écoulèrent avant que la réunion fut cloturée et que John et son équipe furent autorisés à partir.

\thoughtbreak

``Donc, vous me dites que quand Simon est revenu de vacances, il a utilisé une vieille version de la bibliothèque sur le partage réseau et qu'il a pushé son code le plus récent la dedans ?'' Markus retenait la colère.

``Ca ressemble à ça.'' Dit John maussade.

``Oh bordel de merde. Comment c'est arrivé ? Pourquoi il n'a pas utilisé la dernière version ? Et comment la qualification n'a pas détecté ça ?'' Markus regarda John à travers la pièce de réunion.
``John, vous devez vous assurer que cela n'arrive plus jamais. Trouvez une solution !''

\end{trenches}

\subsection{Le problème avec le stockage}
Ce n'est pas que cette situation soit complètement inhabituelle.
A un moment ou à un autre la plupart des gens ont réussi à récupérer du vieux code d'un endroit et à l'utiliser à la place de la dernière version à jour.

Quand on stocke du code sur des partages réseau ou sur des disques locaux, c'est facile de perdre de vue quelle version est quelle version,  
aussi bonne que soit votre convention de nommage.

C'est comme essayer d'assembler un de ces puzzle d'haricots cuits (NDT: un puzzle réputé difficile) quand vous avez 3 boîtes de puzzle et que vous avez versé toutes les pièces dans une boîte dans un souci de simplicité.
Plus aussi simple, n'est ce pas ?

Les gens ont une tendance à utiliser des noms de répertoire qui veut dire quelquechose pour eux.
Cependant cela n'implique pas nécessairement que ce nom signifie quelquechose pour un autre dévelopeur.
``Version 2.3 -- Corrige le bug a'' veut seulement dire quelquechose pour vous si vous savez quel bug est a et quelquechose comme
``Version 2.3 -- Corrige le bug a(2)'' est encore pire.
Malheureusement, autoriser les gens à tapper librement leur propre nom de fichier mènera toujours à des problème comme ça.
Quand ces fichiers sont stockés sur un partage réseau, le problème est 10 fois plus exacerbé parce qu'il n'y a souvent aucun point fixe de référence.

\index{Version Control}Alors quelle est la solution ? Eh bien, dans un grand nombre de cas le contrôle de version peut garantir que non seulement il y a un endroit définit pour stocker les données avec une structure définie, mais aussi que vous avez un historique complet du code.
La responsabilisation (NDT: accountability) est trés importante dans le développement de code, spécialement quand on délivre du code à des clients.
Dans certaines situations un client exigera même que le code développé pour lui soit stocké dans un environnement ou les versions sont contrôllées.
De cette manière, le client peut demander quand une partie du code a été éditée, ou quand un ajout est entré pour la première fois dans la base de code.

\section{Jour 3 - ``Une solution possible''}
\subsection{Nuances sur le contrôle de version}
Il y a plusieurs offre pour le contrôle de version dans la nature, Git, Mercurial, Subversion, CVS et Bazaar pour nommer quelquesunes des solutions Open Source.
Peut-être une question plus pertinente est quel système de contrôle de version utiliser.
Chacun d'eux a ses avantages et ses inconvénients relativement aux autres, mais certains sont plus appropriés à certaines taches que d'autres.
Il est aussi utile de noter que si vous interagissez avec d'autre composant logiciels, ou partagez une partie du développement avec un autre
groupe de dévelopeurs, c'est une bonne idée de leur demander ce qu'ils utilisent.
Généralement vous trouverez la collaboration, le forking et le patching beaucoup plus facile si vous utilisez le même système de contrôle de version que vos partenaires en amont.

\begin{trenches}
``Donc vraiment, il semble que la seule solution réelle à ce problème Klaus en excluant la suggestion de Klaus de réduire l'équipe de production à seulement un dévelopeur, merci Klaus,'' Klaus opina en retour à John, ``est de mettre en place un système de controle de version.''
Markus mordillait sa lèvre.
``Je vois ou vous voulez en venir John, mais les systèmes de controle de version ne sont-ils pas vraiment chers ?''

``Il y a plusieurs solutions open source que nous pourrions regarder en premier,'' intervint une nouvelle voix, ``certaines d'entre elles sont supposées être plutôt bonnes.''

``Allons dans ce sens, regardons les divers avantages et inconvénients et réunissons nous demain pour discuter des résultats,'' dit John.

``Ca vous semble correct ?''
\end{trenches}


Donc maintenant nous devons jeter un oeil aux diverses fonctionnalités des systèmes de contrôle de version et voir quels sont les divers avantages et incovénients de chacun.
Nous allons nous focaliser ici principalement sur git, car c'est l'objet du reste de ce livre.
Il est supposé que si vous lisez ce livre, vous avez très probablement déjà pris votre décision au sujet du système de contrôle de version que vous allez utiliser.
Donc discutons des diverses foncionnalités qui sont les plus répandues dans les systèmes de contrôle de version.

\index{Contrôle de version distribué}\subsection{Contrôle de version distribué}
Les systèmes de contrôle de version se rangent généralement dans une des deux catégories; centalisés, ou distribués.
Git est un système de contrôle de version distribué.
Il a été conçu pour exécuter presque tout localement.
Cela deviendra beaucoup plus clair quand nous discuterons plus tard des autres fonctionnalités de Git, mais pour l'instant, comprenez juste que Git n'est pas lié à un dépôt centralisé.
C'est super puissant.
Non vraiment !

\index{Branchement}\subsection{Branchement}
La plupart des systèmes de contrôle de version offrent le branchement dans leur ensemble de fonctionnalités par défaut. 
Le branchement autorise les développeurs à créer essentiellement un clone de leur dépôt et de le modifier, avec la certitude qu'ils pourront revenir à l'original quand ils en auront besoin.
Cela donne aux développeurs la liberté d'expérimenter toutes sortes de choses sans avoir peur d'affecter la base de code originale/propre.

Git implémente le branchement d'une manière spéciale.
La plupart des anciens systèmes de contrôle de version implémentent le branchment d'une manière qui crée presque toujours une copie séparée du dépôt.
C'es lent et lourd.
La méthode de branchement de Git donne aux développeurs la possibilité de créer plusieurs branches locales pour jouer avec.
De part sa nature distribuée, quand ils poussent (NDT: pushing) du code vers un emplacement plus centralisé d'ou les autres pourront le récuppérer, les développeurs peuvent choisir quelles branches ils veulent pousser, autorisant le code a être testé en privé.

L'implémentation par Git du branchement est rapide.
De part le fait que les dépôt sont stockés locallement, la vitesse de création d'une branche locale est limitée seulement par la vitesse des disques de la machine locale.
L'implémentation de Git est tellement légère que même le facteur vitesse est négligeable.

\index{Mise en attente}\subsection{Mise en attente}
Git gère le commit des changements dans le dépôt différemment de la plupart des autres systèmes de contrôle de version par l'introduction d'une zone de mise en attente (NDT: staging area).
La zone de mise en attente autorise les développeurs de préparer leur commits avant qu'ils ne soient écrits dans le dépôt.
Pourquoi est-ce utile ou même différent de nimporte lequel des autres systèmes de contrôle de version ? 
Avec Git vous pouvez effectuer un changement dans un fichier, l'ajouter à la zone de mise en attente, et ensuite continuer a effecuter des changements dans ce fichier, même en n'ayant en fait pas encore commité quoique ce soit.
Il doit être noté que ce n'est pas absolument nécessaire d'utiliser la zone de mise en attente, mais elle est là pour les développeurs souhaitant l'utiliser.

\index{workflow}\subsection{Workflow}
De part la manière dont il a été conçu, il est possible de l'utiliser dans pratiquement nimporte quel workflow auquel vous pourriez penser.
Trois des workflows les plus courants sont expliqué plus bas, et Git peut fonctionner dans nimporte lequel d'entre eux, ce qui en fait un des systèmes de contrôle de version les plus polyvalente disponible.

\index{workflow!Centralisé}\subsubsection{Workflow Centralisé}
Dans un workflow centralisé, un dépôt partagé unique est utilisé.
Différents développeurs vont y récupérer les changements dans des copies de travail locales, travailler sur la version locale, et la pousser en retour vers vers l'endroit centralisé.

Git gère ce workflow juste comme la plupart des autres systèmes de contrôle de version.
Un développeur ne peut pas pousser ses changements jusqu'à ce qu'il ait tout récupéré (NDT: pulled) jusqu'aux dernières versions du dépôt central et résolu les conflits qui auraient pu apparaître.

En utilisant le modèle centralisé pour le workflow, chaque développeur a le même niveau d'accès au dépôt est considéré comme aussi \textbf{important} qu'un autre.
Pour de petites équipes, cette méthode fonctionnera bien, mais quand les équipes grandissent, une méthode centralisée peut devenir fastidieuse.
Quand de plus en plus de personnes commencent à accéder aux mêmes fichiers, des conflits et d'autres problèmes commencent souvent à apparaître plus fréquemment.

\figuregith{7cm}{images/f-w1-d1.pdf}{Workflow centralisé}

\index{workflow!Gestionnaire d'Intégrations}\subsubsection{Workflow de gestionnaire d'intégration}
Le workflow du gestionnaire d'intégration est similaire au workflow centralisé parce qu'il y a encore un dépôt \textbf{consacré} que tout le monde utilise comme référence.
La différence ici est qu'il n'y a qu'une seule personne qui a le droit de pousser les changements vers le dépôt \textbf{consacré}.
Cette personne est appelée le gestionnaire d'intégration.

Ce workflow est extrèmement bien géré par Git.
Les développeurs vont travailler localement sur leurs dépôts et quand ils seront satisfaits, pousser leur changements vers un endroit où le gestionnaire d'intégration peut les voir.
Le gestionnaire d'intégration observera les modifications que ces développeurs ont fait et les fusionnera (NDT: merge) dans son propre dépôt.
Une fois qu'ils seront satisfaits que tout fonctionne bien, le gestionnaire d'intégration poussera leurs changements vers le dépôt consacré afin que tous les autres développeurs puisse accéder aux changements.

\figuregith{7cm}{images/f-w1-d2.pdf}{Workflow du gestionnaire d'intégration}

\index{workflow!Dictateur et Lieutenant}\subsubsection{Workflow du dictateur et du Lieutenant}
Le workflow du dictateur et du lieutenant est pratiquement une extension du workflow du gestionnaire d'intégration.
Il est plus adapté à de grandes équipes, où des modules ou sections du code peuvent être assignés à un \textbf{Lieutenant} qui est responsable de consacrer tous les changements à cette section particulière.

Une fois que les Lieutenants sont satisfaits de leur code, ils le rendent disponible pour le Dictateur.
Le Dictateur a alors un rôle similaire à celui du Gestionnaire d'Intégration du modèle précédent.
A la fin, tous les changments sont poussés vers le dépôt consacré pour que les développeurs puissent les récupérer à la base de l'arbre (NDT: nimporte quoi...)

\figuregith{7cm}{images/f-w1-d3.pdf}{Workflow Dictateur et Lieutenant}

\begin{callout}{Terminology}{Blessed}\index{blessed (repository)}
Un dépôt consacré (NDT: blessed), ou canonique est celui qui a l'approbation des gestionnaire du projet.
Le dépôt consacré est supposé être le standard de facto d'où tous les autres clones sont tirés.
Si vous hébergez le projet dans un endroit public, le dépôt consacré sera généralement celui qui sera rendu disponible aux gens comme point
de départ stable d'où commencer leur développement.
\end{callout}

La principale chose à retenir, est que Git peut utiliser n'importe lequel de ces workflows.
Cela en fait un système trés flexible, vous autorisant à travailler quelque soit la manière que vous choisissez (NDT: pas joli)

\index{Commit déconnecté}\subsection{Commit déconnecté}
Peut être une des fonctionnalités la plus utile et la plus sous-évaluée des systèmes de contrôle de version distribué est le commit déconnecté (NDT: Offline commiting).
Elle est peut-être sous-évalué car tous les systèmes de contrôle de version ne l'ont pas.
Le commit déconnecté est la capacité à continuer à ajoujer et commiter des fichiers dans le dépot sans être connecté à un dépot centralisé.

Quand on voyage ou juste quand on est hors du bureau, les développeurs ainsi que les intégrateurs peuvent continuer à gérer le code, voir l'historique, voir les diffs et commiter les changement à leur dépôt.
C'est entièrement du au fait que Git effectue 99\% de toutes ses opérations localement.
Quand est dépôt est cloné, Git effectue en réalite une copie complète du dépôt locallement, ce qui donne aux développeurs la flexibilité de travailler partout, sans avoir besoin d'un accès au réseau de la société.

De retour au bureau, les développeurs poussent simplement leurs changements vers leur espace ``public'', qu'il soit local ou un endroit consacré, et tous les commits qu'ils ont effectués alors qu'ils étaient en déplacement sont alors rendu disponible pour le reste de l'équipe, incluant tout l'historique et les instantanés (TODO: snapshots ?).

\index{interaction avec le développeur}\subsection{Interaction avec le développeur}
Un facteur à considérer quand on choisit un système de contrôle de version, est celui de l'interaction avec le développeur.
Par cela nous faisons réferrence à la manière dont les développeurs utilisent et interagissent avec le systèmes de contrôle de version lui-même.
Il y a 4 principales méthodes d'interaction avec un VCS.

\index{interface utilisateur}\index{interface utilisateur!GUI}\subsubsection{Client d'interface utilisateur graphique (GUI)}
Une interface utilisatateur graphique autorise le développeur, ou l'utilisateur, à manipuler le dépôt en utilisant une souris et un environnement riche en graphique.
Un client GUI consist typiquement en une application séparée qui est exécuté quand un utilisateur veut effectuer des changement dans le dépôt tel qu'ajouter des fichiers ou commiter des changements.

Certains développeurs préfèrent avoir un client séparé avec lequel ils peuvent interagir avec leur dépôt, alors que d'autres préfèrent avoir les choses un peu plus intégrées.


\index{interface utilisateur!extension shell}\subsubsection{Intégration des extension dans le Shell}
L'intégration au Shell autorise l'utilisteur à interagir avec leur dépôt en utilisant l'environnement graphique qu'il utiliserait généralement pour manipuler les fichiers et effectuer les opérations de maintenance de répertoire.
Une des extension Shell les plus communes pour Git est l'interface msygit qui s'intègre à Windows Explorer, autorisant l'utilisateur à effectuer un click droit sur une entité à l'intèrieur d'un arbre de travail Git, et se voir présenter un menu contextuel pour effectuer des opérations de VCS.

\index{interface utilisateur!ligne de commande}\subsubsection{Interface de Ligne de Commande (CLI)}
L'interface de ligne de command est préférée par beaucoup de développeurs car ils peuvent écrire des scripts avec et voir exactement ce qui se passe, souvent avec beaucoup plus de détail qu'avec une interface graphique (GUI).
La CLI donne un contrôle total sur le système et il vaut la peine de noter que presque tous les systèmes de contrôle de version commencent leur vie en tant qu'interfaces pilotées par la ligne de commande.
Pourquoi cela ? Cela peut prendre beaucoup de temps et d'efforts pour mettre toutes les options et nuances d'un système dans une interface graphique.
La CLI sera preque toujours le plus puissant de tous les outils, spécialement lorsqu'il sagit de systèmes de contrôle de version.

\section{Jour 4 - ``Une décision est prise''}
\subsection{Analyser vos besoins}
L'aspect le plus important quand on choisit un sytème de contrôle de version est de définir vos besoins.
Ils peuvent être peu nombreux, ou assez spécifiques. Voyons ce que John et son équipe considèrent comme les aspects les plus importants et finalement pour quel VCS ils se décident.

\begin{trenches}
``Le commit déconnecté semble être une chose utile à avoir.'' Dit Mike en hochant la tête.
``En particulier avec des personnes comme John qui voyagent tout le temps.''

``Je dois l'admettre, ça serait bien d'être dans l'avion, et d'être capable de récupérer (NDT: pull) l'ensemble du code, en connaissant tout l'historique de chaque section,'' répondit John.
``Le branchement dans Git semble être assez puissant aussi.''

``Je dois admettre,'' renchérit Klaus, ``J'ai utilisé le branchement un peu dans Subversion avant et c'était inestimable.
C'est sensé être super rapide dans Git aussi.''

``Et de part le fait que Git semm suporter plusieurs workflows, cela veut dire que nous pouvons les essayer et voir comment ils marchent pour nous.'' Markus regarda l'équipe.
``Alors on est d'accord pour Git ?''

L'éauipe acquiesca et tout le monde sortit de la salle de réunion excepté John.
Les choses allaient devenir intéressantes pour lui.
Trés intéressantes.
\end{trenches}

Comme ce book est sur Git, nous n'allons pas trop approfondir les fonctionnalités ou fonctionnalités des autres système de contrôle de version.
Espérons que ce chapitre vous a donné assez d'information pour aller vérifier certains des autres systèmes si vous en ressentez le besoin.
La principale chose à garder à l'esprit est que Git est un Système de Contrôle de Version Distribué ou DVCS.
Bien qu'il en soit ainsi, il est également important de se souvenir qu'il peut être utilisé dans des modèles de workflows similaires à ceux des systèmes de contrôles de versions centralisés.

Les besoins de John et son équipe n'ont rien de spécial.
C'est une petite équipe qui cherche à profiter d'avoir son code dans un système bien organisé.
Ils cherchent aussi à réorganiser les fonctions et dynamiques d'équipe pour s'adapter au système de contrôle de version et l'intégrer réellement au coeur de leur développement.

Le contrôle de version ne remplace pas un workflow.
Il n'est pas prévu pour tout rendre meilleur.
Si vous avez des personnes qui prennent le large et font leurs propres affaires en ne faisant pas attention à leur manière de travailler, le contrôle de version ne va pas soudainement tout régler.
Un n'outil n'est qu'un outil et le contrôle de version n'est pas différent.

Vous pouvez engager le constructeur le plus désordonné du marché et une belle boite à outil flambant neuve, mais à moins qu'il n'ait la volonté de changer, vous alleza probablement découvrir que tous les outils finissent au fond tu plus grand compartiment du fond.

\section{Jour 5 - ``Travailler comme un équipe''}
\index{organisation d'équipe}\subsection{Organisation d'équipe}
Mainteant que nous nous sommes occupé des bases, jettons un petit coup d'oeil à comment Johan organise son équipe, et voyons si le contrôle de version va fonctionner pour eux.
Il est important que l'équipe comprenne comment le modèle doit fonctionner, ce qu'ils sont supposés faire et quel niveau d'accès ils ont.
La plupart des personnes seront plus frustrés de ne pas savoir ce qu'ils devaient ou ne devaient pas faire, plutôt que qu'avoir ou ne pas avoir accés à certaines choses.

\begin{trenches}
Il etait 16h36 vendredi et la table de la salle de présentation était jonchée de cannettes de coca vides, de boîtes de pizza et une boîte à repas japonaise bento, appartenant à un membre particulièrement tétu de l'équipe qui avait fait voeu de ne jamais plus manger de pizza.
L'équipe essayait de se décider sur la manière de s'organiser.

``Il n'y a rien qui nous interdise d'utiliser une combinaison des modèles, n'est ce pas ?'' demanda Mike.

``Je suppose que non'' diT John.
``Qu'est ce que tu as à l'esprit'' Ses lunettes glissaient en bas de son front maintenant et il commencait à être bien fatigué.

``Bien, Je suppose, nous avons à la base le logiciel sépara en deux parties. Nous avons la bibliothèqe, sur laquelle Klaus, Jack et moi même travaillons. Ensuite nous avons les élément de la UI que gérent Simon, Martha et Rob. Je sais qu'il y a aussi les outils sur lesquels travaille Eugene''
Tout le monde avait commencé à écouter alors que Mike continuait.
``John, tu n'a pas à t'occuper du composant bibliothèque comme c'est plus le domaine de Klaus. Alors pourquoi ne pas avoir deux dictateurs. Klaus et toi avez acccés pour pousser vers le dépôt consacré. John peut puller de ses gars, et Klaus des sien et au final on a un bon modèle pour le contrôle de version.''

John leva ses sourcils, ``Pas mal Mike,'' dit-il, sincèrement impressionné.
Aprsè avoir passé quelques heures à évaluer les différents modèless et qui était en charge de quoi, ça faisait du bien d'avoir finalement pris une décision.

``Alors, on commence lundi donc ?'' demanda Markus, qui écoutait de l'autre bout de la table.

``En effet.'' Annonça Klaus, ``Lundi on est tous sous Git!''
\end{trenches}
