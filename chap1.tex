% chap1.tex - Week 1
\chapter{Semaine 1}
\section{Jour 1 - ``Les choses doivent changer''}
\subsection{Réunir l'équipe}
Si vous êtes déjà un utilisateur chevronné de contrôle de version, vous pourriez vouloir sauter ce chapitre.
C'est une sorte d'introduction à pourquoi nous avons même besoin de systèmes de contrôle de version en premier lieu.
Ce chapitre observe aux besoins de Tamagoyaki Inc. et pourquoi ils choisissent le VCS (NDT: Version Control System, ce terme standard ne sera pas traduit dans la suite du document) qui semblait leur convenir.
Tamagoyaki Inc. crée un logiciel qui transforme un PC standard en media center.
Leur produits est destiné à l'utilisateur final et ils sont fortement dépendants d'une bonne présence aux salons commerciaux, pour ramener des ventes.
La conversation suivante décrit les évènements qui ont conduit à l'établissement de la discussion "Nous avons besoin d'un VCS!".

\begin{trenches}
John s'assit à son bureau et regarda à travers la fenêtre.
La bruine tombait sur le volet, mais il s'en fichait.
C'était un lundi tranquille, la livraison s'était bien déroulée vendredi et John était juste en train de penser à l'implémentation the la nouvelle couche d'abstraction à la base de données qui lui avait été demandée.
``John,'' hurla son patron, Markus, ``amenez votre équipe dans la salle de présentation. Maintenant !''

Les choses ne se présentaient pas bien.

\thoughtbreak

``Alors, ce que nous aimerions savoir John, c'est juste comment un bug qui était supposé avoir été corrigé\ldots'' le PDG se reprit,

``qui avait été certifié comme étant fixé il y a 2 semaines, a pu se glisser dans la dernière version de notre logiciel ?''

``Je suis désolé,'' commença John, avant d'être interrompu.

``Être désolé ne suffit pas John,'' dit le PDG, Wayne Tobi,
``Ce fut presque une déconfiture majeure pour Tamgayoki Inc. et nous avons besoin de nous assurer que cela ne se reproduise pas à nouveau. Ladémonstration au salon était à 2 doigts de l'échec complet. Heureusement quelqu'un avait eu le bon sens d'amener une machine de sauvegarde.''

Il se tourna vers Markus.
``Je veux un rapport sur mon bureau d'ici la fin de la journée qui explique quel était le problème, comment il nous a glissé des mains et quelles mesures préventives nous allons mettre en oeuvre pour que des choses comme ça ne se reproduise plus jamais.''

``Bien sur monsieur,'' répondit Markus.
Il était rouge vif avec un embaras tout personnel.

La pièce devint silencieuse et quelques minutes de silence s'écoulèrent avant que la réunion fut cloturée et que John et son équipe furent autorisés à partir.

\thoughtbreak

``Donc, vous me dites que quand Simon est revenu de vacances, il a utilisé une vieille version de la bibliothèque sur le partage réseau et qu'il a pushé son code le plus récent la dedans ?'' Markus retenait la colère.

``Ca ressemble à ça.'' Dit John maussade.

``Oh bordel de merde. Comment c'est arrivé ? Pourquoi il n'a pas utilisé la dernière version ? Et comment la qualification n'a pas détecté ça ?'' Markus regarda John à travers la pièce de réunion.
``John, vous devez vous assurer que cela n'arrive plus jamais. Trouvez une solution !''

\end{trenches}

\subsection{Le problème avec le stockage}
Ce n'est pas que cette situation soit complètement inhabituelle.
A un moment ou à un autre la plupart des gens ont réussi à récupérer du vieux code d'un endroit et à l'utiliser à la place de la dernière version à jour.

Quand on stocke du code sur des partages réseau ou sur des disques locaux, c'est facile de perdre de vue quelle version est quelle version,  
aussi bonne que soit votre convention de nommage.

C'est comme essayer d'assembler un de ces puzzle d'haricots cuits (NDT: un puzzle réputé difficile) quand vous avez 3 boîtes de puzzle et que vous avez versé toutes les pièces dans une boîte dans un souci de simplicité.
Plus aussi simple, n'est ce pas ?

Les gens ont une tendance à utiliser des noms de répertoire qui veut dire quelquechose pour eux.
Cependant cela n'implique pas nécessairement que ce nom signifie quelquechose pour un autre dévelopeur.
``Version 2.3 -- Corrige le bug a'' veut seulement dire quelquechose pour vous si vous savez quel bug est a et quelquechose comme
``Version 2.3 -- Corrige le bug a(2)'' est encore pire.
Malheureusement, autoriser les gens à tapper librement leur propre nom de fichier mènera toujours à des problème comme ça.
Quand ces fichiers sont stockés sur un partage réseau, le problème est 10 fois plus exacerbé parce qu'il n'y a souvent aucun point fixe de référence.

\index{Version Control}Alors quelle est la solution ? Eh bien, dans un grand nombre de cas le contrôle de version peut garantir que non seulement il y a un endroit définit pour stocker les données avec une structure définie, mais aussi que vous avez un historique complet du code.
La responsabilisation (NDT: accountability) est trés importante dans le développement de code, spécialement quand on délivre du code à des clients.
Dans certaines situations un client exigera même que le code développé pour lui soit stocké dans un environnement ou les versions sont contrôllées.
De cette manière, le client peut demander quand une partie du code a été éditée, ou quand un ajout est entré pour la première fois dans la base de code.

\section{Jour 3 - ``Une solution possible''}
\subsection{Nuances sur le contrôle de version}
Il y a plusieurs offre pour le contrôle de version dans la nature, Git, Mercurial, Subversion, CVS et Bazaar pour nommer quelquesunes des solutions Open Source.
Peut-être une question plus pertinente est quel système de contrôle de version utiliser.
Chacun d'eux a ses avantages et ses inconvénients relativement aux autres, mais certains sont plus appropriés à certaines taches que d'autres.
Il est aussi utile de noter que si vous interagissez avec d'autre composant logiciels, ou partagez une partie du développement avec un autre
groupe de dévelopeurs, c'est une bonne idée de leur demander ce qu'ils utilisent.
Généralement vous trouverez la collaboration, le forking et le patching beaucoup plus facile si vous utilisez le même système de contrôle de version que vos partenaires en amont.

\begin{trenches}
``Donc vraiment, il semble que la seule solution réelle à ce problème Klaus en excluant la suggestion de Klaus de réduire l'équipe de production à seulement un dévelopeur, merci Klaus,'' Klaus opina en retour à John, ``est de mettre en place un système de controle de version.''
Markus mordillait sa lèvre.
``Je vois ou vous voulez en venir John, mais les systèmes de controle de version ne sont-ils pas vraiment chers ?''

``Il y a plusieurs solutions open source que nous pourrions regarder en premier,'' intervint une nouvelle voix, ``certaines d'entre elles sont supposées être plutôt bonnes.''

``Allons dans ce sens, regardons les divers avantages et inconvénients et réunissons nous demain pour discuter des résultats,'' dit John.

``Ca vous semble correct ?''
\end{trenches}


Donc maintenant nous devons jeter un oeil aux diverses fonctionnalités des systèmes de contrôle de version et voir quels sont les divers avantages et incovénients de chacun.
Nous allons nous focaliser ici principalement sur git, car c'est l'objet du reste de ce livre.
Il est supposé que si vous lisez ce livre, vous avez très probablement déjà pris votre décision au sujet du système de contrôle de version que vous allez utiliser.
Donc discutons des diverses foncionnalités qui sont les plus répandues dans les systèmes de contrôle de version.

\index{Contrôle de version distribué}\subsection{Contrôle de version distribué}
Les systèmes de contrôle de version se rangent généralement dans une des deux catégories; centalisés, ou distribués.
Git est un système de contrôle de version distribué.
Il a été conçu pour exécuter presque tout localement.
Cela deviendra beaucoup plus clair quand nous discuterons plus tard des autres fonctionnalités de Git, mais pour l'instant, comprenez juste que Git n'est pas lié à un dépôt centralisé.
C'est super puissant.
Non vraiment !

\index{Branchement}\subsection{Branchement}
La plupart des systèmes de contrôle de version offrent le branchement dans leur ensemble de fonctionnalités par défaut. 
Le branchement autorise les développeurs à créer essentiellement un clone de leur dépôt et de le modifier, avec la certitude qu'ils pourront revenir à l'original quand ils en auront besoin.
Cela donne aux développeurs la liberté d'expérimenter toutes sortes de choses sans avoir peur d'affecter la base de code originale/propre.

Git implémente le branchement d'une manière spéciale.
La plupart des anciens systèmes de contrôle de version implémentent le branchment d'une manière qui crée presque toujours une copie séparée du dépôt.
C'es lent et lourd.
La méthode de branchement de Git donne aux développeurs la possibilité de créer plusieurs branches locales pour jouer avec.
De part sa nature distribuée, quand ils poussent (NDT: pushing) du code vers un emplacement plus centralisé d'ou les autres pourront le récuppérer, les développeurs peuvent choisir quelles branches ils veulent pousser, autorisant le code a être testé en privé.

L'implémentation par Git du branchement est rapide.
De part le fait que les dépôt sont stockés locallement, la vitesse de création d'une branche locale est limitée seulement par la vitesse des disques de la machine locale.
L'implémentation de Git est tellement légère que même le facteur vitesse est négligeable.

\index{Mise en attente}\subsection{Mise en attente}
Git gère le commit des changements dans le dépôt différemment de la plupart des autres systèmes de contrôle de version par l'introduction d'une zone de mise en attente (NDT: staging area).
La zone de mise en attente autorise les développeurs de préparer leur commits avant qu'ils ne soient écrits dans le dépôt.
Pourquoi est-ce utile ou même différent de nimporte lequel des autres systèmes de contrôle de version ? 
Avec Git vous pouvez effectuer un changement dans un fichier, l'ajouter à la zone de mise en attente, et ensuite continuer a effecuter des changements dans ce fichier, même en n'ayant en fait pas encore commité quoique ce soit.
Il doit être noté que ce n'est pas absolument nécessaire d'utiliser la zone de mise en attente, mais elle est là pour les développeurs souhaitant l'utiliser.

\index{workflow}\subsection{Workflow}
De part la manière dont il a été conçu, il est possible de l'utiliser dans pratiquement nimporte quel workflow auquel vous pourriez penser.
Trois des workflows les plus courants sont expliqué plus bas, et Git peut fonctionner dans nimporte lequel d'entre eux, ce qui en fait un des systèmes de contrôle de version les plus polyvalente disponible.

\index{workflow!Centralisé}\subsubsection{Workflow Centralisé}
Dans un workflow centralisé, un dépôt partagé unique est utilisé.
Différents développeurs vont y récupérer les changements dans des copies de travail locales, travailler sur la version locale, et la pousser en retour vers vers l'endroit centralisé.

Git gère ce workflow juste comme la plupart des autres systèmes de contrôle de version.
Un développeur ne peut pas pousser ses changements jusqu'à ce qu'il ait tout récupéré (NDT: pulled) jusqu'aux dernières versions du dépôt central et résolu les conflits qui auraient pu apparaître.

En utilisant le modèle centralisé pour le workflow, chaque développeur a le même niveau d'accès au dépôt est considéré comme aussi \textbf{important} qu'un autre.
Pour de petites équipes, cette méthode fonctionnera bien, mais quand les équipes grandissent, une méthode centralisée peut devenir fastidieuse.
Quand de plus en plus de personnes commencent à accéder aux mêmes fichiers, des conflits et d'autres problèmes commencent souvent à apparaître plus fréquemment.

\figuregith{7cm}{images/f-w1-d1.pdf}{Workflow centralisé}

\index{workflow!Gestionnaire d'Intégrations}\subsubsection{Workflow de gestionnaire d'intégration}
Le workflow du gestionnaire d'intégration est similaire au workflow centralisé parce qu'il y a encore un dépôt \textbf{consacré} que tout le monde utilise comme référence.
La différence ici est qu'il n'y a qu'une seule personne qui a le droit de pousser les changements vers le dépôt \textbf{consacré}.
Cette personne est appelée le gestionnaire d'intégration.

Ce workflow est extrèmement bien géré par Git.
Les développeurs vont travailler localement sur leurs dépôts et quand ils seront satisfaits, pousser leur changements vers un endroit où le gestionnaire d'intégration peut les voir.
Le gestionnaire d'intégration observera les modifications que ces développeurs ont fait et les fusionnera (NDT: merge) dans son propre dépôt.
Une fois qu'ils seront satisfaits que tout fonctionne bien, le gestionnaire d'intégration poussera leurs changements vers le dépôt consacré afin que tous les autres développeurs puisse accéder aux changements.

\figuregith{7cm}{images/f-w1-d2.pdf}{Workflow du gestionnaire d'intégration}

\index{workflow!Dictateur et Lieutenant}\subsubsection{Workflow du dictateur et du Lieutenant}
Le workflow du dictateur et du lieutenant est pratiquement une extension du workflow du gestionnaire d'intégration.
Il est plus adapté à de grandes équipes, où des modules ou sections du code peuvent être assignés à un \textbf{Lieutenant} qui est responsable de consacrer tous les changements à cette section particulière.

Une fois que les Lieutenants sont satisfaits de leur code, ils le rendent disponible pour le Dictateur.
Le Dictateur a alors un rôle similaire à celui du Gestionnaire d'Intégration du modèle précédent.
A la fin, tous les changments sont poussés vers le dépôt consacré pour que les développeurs puissent les récupérer à la base de l'arbre (NDT: nimporte quoi...)

\figuregith{7cm}{images/f-w1-d3.pdf}{Workflow Dictateur et Lieutenant}

\begin{callout}{Terminology}{Blessed}\index{blessed (repository)}
Un dépôt consacré (NDT: blessed), ou canonique est celui qui a l'approbation des gestionnaire du projet.
Le dépôt consacré est supposé être le standard de facto d'où tous les autres clones sont tirés.
Si vous hébergez le projet dans un endroit public, le dépôt consacré sera généralement celui qui sera rendu disponible aux gens comme point
de départ stable d'où commencer leur développement.
\end{callout}

La principale chose à retenir, est que Git peut utiliser n'importe lequel de ces workflows.
Cela en fait un système trés flexible, vous autorisant à travailler quelque soit la manière que vous choisissez (NDT: pas joli)

\index{offline committing}\subsection{Offline Committing}
Perhaps one of the most useful and undervalued features of distributed version control systems is that of offline committing.
It may be undervalued because not all version control systems have it.
Offline committing is the ability to continue adding and committing files to the repository without being connected to a centralised repository.

When travelling or just simply when out of the office, developers and integrators alike are able to continue managing code, viewing histories, viewing diffs and committing changes to their repository.
This is all due to the fact that Git does 99\% of all of its operations locally.
When a repository is cloned, Git actually sets up a copy of the entire repository locally, giving developers the flexibility to work anywhere, without requiring access to the company network.

When returning to the office, the developers simply push their changes to their ``public'' space, be it local or to a blessed location, and all of the commits that have been made whilst they are away are then made available to the rest of the team, including all history and snapshots.

\index{developer interaction}\subsection{Developer Interaction}
One factor to consider when choosing a version control system, is that of developer interaction.
By this we are referring to the way in which developers use and interact with the version control system itself.
There are four main methods for VCS interaction

\index{user interface}\index{user interface!GUI}\subsubsection{Graphical User Interface Client (GUI)}
A graphical user interface allows the developer, or user, to physically manipulate the repository using a mouse pointer and a graphically rich environment.
A GUI client will typically consist of separate application which is run when a user wants to make changes to a repository such as adding files or committing changes.

Some developers prefer having a separate client with which to interact with their repository, whilst others prefer to have things integrated a little more.

\index{user interface!shell extension}\subsubsection{Shell Extension Integration}
Shell integration allows the user to interact with their repository using the graphical environment that they would usually use for manipulating files and performing routine directory maintenance.
One of the most common Shell Extensions for Git is the msysgit interface which integrates itself into Windows Explorer, allowing a user to right click on an entity whilst inside a git working tree, and be presented with a context sensitive menu for entering a shell for VCS operations.

\index{user interface!command line}\subsubsection{Command Line Interface (CLI)}
The command line interface is favoured by many developers as they can script with it and can see exactly what is going on, often in much more detail that with a GUI.
The CLI gives total control over the system and it is worth noting that almost all version control systems start life as command line driven interfaces.
Why is this so? It can take a lot of time and effort to put all the options and nuances of a system into a GUI.
The CLI will almost always be the most powerful of all tools, especially where version control systems are concerned.

\section{Day 4 - ``A decision is reached''}
\subsection{Analysing Your Requirements}
The most important aspect of choosing a version control system is to define your requirements.
These can be few, or they can be quite specific. Let's see what John and his team decide are the most important aspects for them and ultimately what VCS they decide upon.

\begin{trenches}
``Offline committing seems like it's a pretty useful thing to have.'' Mike said nodding.
``Especially with people like John travelling all the time.''

``I have to admit, it would be nice to be on the plane, and be able to pull all the code together, knowing all of the history of each section,'' replied John.
``The branching in Git seems to be quite powerful as well.''

``I must admit,'' chimed in Klaus, ``I've used branching a bit in Subversion before and it was a lifesaver.
It's supposed to be super fast in Git too.''

``And owing to the fact that Git seems to support several workflows, it means we can try them out and see how they work for us.'' Markus looked at the team.
``Are we settled on Git then?''

The team nodded and everyone walked out of the board room except John.
Things were about to get interesting for him.
Very interesting.
\end{trenches}

Since this book is all about Git, we won't delve too far into the workings or features of other version control systems.
Hopefully, this chapter has given you enough information to go and check out some of the other systems if you feel the need to.
The main thing to bear in mind is that Git is a Distributed Version Control System or DVCS.
While this is so, it is equally important to remember that it can be used in the same workflow models as centralised version control systems.

John and his teams requirements are nothing special.
They are a smallish team looking to reap the benefits of having their code in a well organised system.
They are also looking to reorder their team functions and dynamics in order to fit around the version control system and really make it core to their development.

Version control is not a replacement for workflow.
It is not intended to make everything better.
If you have people going off and doing their own thing and being careless about the way they work, version control is not going to suddenly fix everything.
A tool is just that, a tool and version control is no different.
You can buy the messiest builder in the trade a nice shiny new tool box, but unless they have the mindset to want to change, you'll probably find that all the tools end up in the largest compartment at the bottom.

\section{Day 5 - ``Working like a team''}
\index{team organisation}\subsection{Team Organisation}
Now that we have the basics dealt with, let's take a little look at how John arranges his team, and see whether version control is going to work for them.
It is important that the team understands how the model should work, what they are expected to do and what level of access they have.
Most of the time people will get more frustrated about not knowing what they should or should not be doing, rather than that they do or don't have access to certain things.

\begin{trenches}
It was 4:36pm on the Friday and the table in the board room was littered with empty coke cans, pizza boxes and one Japanese bento lunchbox, owned by a particularly stubborn member of the team who had vowed never to eat pizza again.
It had been Marcus' idea to bring in the food reinforcement to help the discussions along.
The team were trying to decide how to organise their model.

``There's nothing to say we can't use a combination of the models is there?'' asked Mike.

``I suppose not,'' said John.
``What did you have in mind.'' His glasses were slipping down his forehead now and he was getting pretty tired.

``Well, I figure, we basically have the software split into two parts. We have the library, which myself, Klaus and Jack work on. Then there's the UI elements which Simon, Martha and Rob handle. I know there are the tools which Eugene works on too.''
Everyone had started to listen to Mike as he continued.
``John, you don't want to have to deal with the library component as this more Klaus' space. So why don't we have two dictators. Klaus and yourself have access to push up to the blessed repository. John can pull from his guys, Klaus from his and we end up with a good model for version control.''

John raised his eyebrows, ``Not bad Mike,'' he said, genuinely impressed.
After spending a few hours going through the various models and who was in charge of what, it felt good to have finally reached a decision.

``So, we start on Monday then?'' asked Markus, who had been listening from the other end of the table.

``Indeed.'' Announced Klaus, ``Monday we all become Gits!''
\end{trenches}
